/**
 * @file quadtree.cpp
 * Quadtree class implementation.
 * @date Spring 2008
 */
#include "quadtree.h"
#include <iostream>
using namespace std;

//no argument constructor
Quadtree::Quadtree(){
  root = NULL;
  resolution = 0;
}

//buildTree function
void Quadtree::buildTree(PNG const & source,int resolution ){//need to set resolution also in build tree function
  clear(root);
  this->resolution = resolution;
  root = buildTreeHelper(source,resolution,0,0);
}
  // x,y = upper-left pixel
Quadtree::QuadtreeNode* Quadtree::buildTreeHelper(PNG const & source,int resolution, int x,int y){
  if(resolution == 1){
    QuadtreeNode* leafNode = new QuadtreeNode(*(source(x,y)));
    return leafNode;
  }
  QuadtreeNode* newNode = new QuadtreeNode();
  newNode->nwChild = buildTreeHelper(source,resolution/2,x,y);
  newNode->neChild = buildTreeHelper(source,resolution/2,x+resolution/2,y);
  newNode->swChild = buildTreeHelper(source,resolution/2,x,y+resolution/2);
  newNode->seChild = buildTreeHelper(source,resolution/2,x+resolution/2,y+resolution/2);
  uint8_t redAvg = (newNode->nwChild->element.red + newNode->neChild->element.red + newNode->swChild->element.red + newNode->seChild->element.red)/4;
  uint8_t blueAvg = (newNode->nwChild->element.blue + newNode->neChild->element.blue + newNode->swChild->element.blue + newNode->seChild->element.blue)/4;
  uint8_t greenAvg = (newNode->nwChild->element.green + newNode->neChild->element.green + newNode->swChild->element.green + newNode->seChild->element.green)/4;
  RGBAPixel average(redAvg,greenAvg,blueAvg);
  newNode->element = average;
  return newNode;
}

//two argument constructor
Quadtree::Quadtree(PNG const &source,int resolution){
  root = buildTreeHelper(source,resolution,0,0);
  this->resolution = resolution;
}

//copy constructor
Quadtree::Quadtree(Quadtree const &other){
  this->resolution = other.resolution;
  root = copy(other.root);
}

//overloading operator
const Quadtree& Quadtree::operator=(Quadtree const &other){
  if(this != &other){
    clear(root);
    this->resolution = other.resolution;
    root = copy(other.root);
  }
  return *this;
}

Quadtree::QuadtreeNode* Quadtree::copy(QuadtreeNode* root){
    if(root == NULL){
      return NULL;
    }
    QuadtreeNode* t = new QuadtreeNode(root->element);
    t->nwChild = copy(root->nwChild);
    t->neChild = copy(root->neChild);
    t->swChild = copy(root->swChild);
    t->seChild = copy(root->seChild);
    return t;
  }
//Destructor
Quadtree::~Quadtree(){
  clear(root);
}

void Quadtree::clear(QuadtreeNode* croot){
  if(croot!=NULL){
    clear(croot->nwChild);
    clear(croot->neChild);
    clear(croot->swChild);
    clear(croot->seChild);
    delete croot;
    croot = NULL;
  }
}

RGBAPixel Quadtree::getPixel(int x, int y) const{
  return getPixelHelper(x,y,this->resolution,this->root);
}

RGBAPixel Quadtree::getPixelHelper(int x, int y, int resolution, QuadtreeNode* root) const{
  if(root == NULL||x>resolution||y>resolution||x<0||y<0){//check for null root or coords are out of bound
    return RGBAPixel();
  }
  //base case, if any of the child is null, it is a leaf node
  if(root->nwChild==NULL){//if any of the child is null, it is a leafNode
    return root->element;
  }
  else{
  //check condition to locate the coords of the node , 4 recursive cases resolution/2...
  //"bigger than" relation should be used >= since if the resolution is 4, we want 0,1||3,4
    if(x<resolution/2&&y<resolution/2){//nwChild
      return getPixelHelper(x,y,resolution/2,root->nwChild);
    }
    else if(x>=resolution/2&&y<resolution/2){//neChild
      return getPixelHelper(x-resolution/2,y,resolution/2,root->neChild);
    }
    else if(x<resolution/2&&y>=resolution/2){//swChild
      return getPixelHelper(x,y-resolution/2,resolution/2,root->swChild);//the coords will be relative to the small square
    }
    else{//seChild
      return getPixelHelper(x-resolution/2,y-resolution/2,resolution/2,root->seChild);
    }
  }
}

PNG Quadtree::decompress() const{
  //construct a PNG object with width = height = resolution
  //traverse until the leaf nodes and get the rgbapixel at that node
  //set the (x,y) location at the png object
  if(this->root == NULL) return PNG();//can i just build it on stack?????
  PNG retimg(this->resolution,this->resolution);
  for(size_t i = 0;i<resolution;i++){
    for(size_t j = 0;j<resolution;j++){
      *(retimg(i,j)) = getPixel(i,j);
    }
  }
  return retimg;
}
//root and resolution
